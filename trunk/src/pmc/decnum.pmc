#include <string.h>
#include "parrot/parrot.h"
#include "../decNumber/decNumber.h"

static void
check_flags_and_throw(PARROT_INTERP, decContext *ctx) {
    if ( ctx->status & DEC_Errors)
        Parrot_ex_throw_from_c_args(interp, NULL,
                                    EXCEPTION_INVALID_OPERATION,
                                    decContextStatusToString(ctx));
}

static decContext *
get_context( PMC *pmc) {
    return PARROT_DECBASE(pmc)->ctx;
}

pmclass DecNum 
    dynpmc 
    group decnumber 
    extends DecBase {

    ATTR PMC              *context;
    ATTR struct decNumber *number;

    METHOD version() {
        STRING* version;

        version = Parrot_str_new(INTERP, decNumberVersion(), 0);

        RETURN(STRING *version);
    }

    VTABLE PMC *instantiate(PMC *sig) {
        UNUSED(sig)
        return PMCNULL;
    }

    VTABLE void init() {
        INTVAL context_type;
        Parrot_DecNum_attributes *attr = NULL;

        if (decContextTestEndian(1)) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, 
            EXCEPTION_INVALID_OPERATION,  
            "This dynpmc has been compiled with the wrong endianness.");
        }

        attr = mem_allocate_zeroed_typed(Parrot_DecNum_attributes);
        attr->ctx = NULL;

        attr->number = mem_allocate_typed(decNumber);
        decNumberZero(attr->number);

        context_type = pmc_type(interp, CONST_STRING(interp, "DecNumContext"));
        attr->context = pmc_new(interp, context_type);

        PMC_data(SELF) = attr;

        PObj_active_destroy_SET(SELF); 
        PObj_custom_mark_SET(SELF);
    }

    VTABLE void destroy() {
        mem_sys_free(PARROT_DECNUM(SELF)->number);
        mem_sys_free(PMC_data(SELF));
    }

    VTABLE void mark() {
        Parrot_gc_mark_PObj_alive(interp, 
                                  (PObj*)PARROT_DECNUM(SELF)->context);
    }

    VTABLE void set_string_native(STRING *value) {
        char * const str = Parrot_str_to_cstring(INTERP, value);
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        decNumberFromString(PARROT_DECNUM(SELF)->number, 
                          str, ctxt );
        Parrot_str_free_cstring(str);
        check_flags_and_throw(INTERP, ctxt);
    }  

    VTABLE STRING *get_string() {
        char      *cstr;
        STRING    *pstr;
        decNumber *num;

        num = PARROT_DECNUM(SELF)->number;
        cstr = mem_allocate_n_typed(num->digits + 15, char);
        decNumberToString(num, cstr);
        pstr = Parrot_str_new(INTERP, cstr, 0);
        mem_sys_free(cstr);

        return pstr;
    }

    VTABLE void set_integer_native(INTVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);

        decNumberFromString(PARROT_DECNUM(SELF)->number,
                            cstr, ctxt );
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }  

    VTABLE INTVAL get_integer() {
        decNumber *num = PARROT_DECNUM(SELF)->number;
        char      *cstr = mem_allocate_n_typed(num->digits + 15, char);
        STRING    *pstr;

        decNumberToString(num, cstr);
        pstr = Parrot_str_new(INTERP, cstr, 0);
        mem_sys_free(cstr);

        return Parrot_str_to_int(INTERP, pstr);
    }

    VTABLE void set_number_native(FLOATVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);

        decNumberFromString(PARROT_DECNUM(SELF)->number,
                            cstr, ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }  

    VTABLE FLOATVAL get_number() {
        decNumber *num = PARROT_DECNUM(SELF)->number;
        char      *cstr = mem_allocate_n_typed(num->digits + 15, char);
        STRING    *pstr;

        decNumberToString(num, cstr);
        pstr = Parrot_str_new(INTERP, cstr, 0);
        mem_sys_free(cstr);

        return Parrot_str_to_num(INTERP, pstr);
    }

    VTABLE INTVAL get_bool() {
        return !decNumberIsZero(PARROT_DECNUM(SELF)->number);
    }

    VTABLE PMC *clone() {
        PMC *clone = pmc_new(INTERP, SELF->vtable->base_type);

        decNumberCopy(PARROT_DECNUM(clone)->number, 
                      PARROT_DECNUM(SELF)->number);

        return clone;
    }

    VTABLE void increment() {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        decNumber   one;

        decNumberAdd(PARROT_DECNUM(SELF)->number, 
                     PARROT_DECNUM(SELF)->number, 
                     decNumberFromString(&one , "1", ctxt),
                     ctxt);
        check_flags_and_throw(INTERP, ctxt);

    }

    VTABLE void decrement() {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        decNumber   one;

        decNumberSubtract(PARROT_DECNUM(SELF)->number, 
                          PARROT_DECNUM(SELF)->number, 
                          decNumberFromString(&one , "1", ctxt),
                          ctxt);
        check_flags_and_throw(INTERP, ctxt);

    }

    VTABLE PMC *add(PMC *value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberAdd(PARROT_DECNUM(dest)->number,
                         PARROT_DECNUM(SELF)->number,
                         PARROT_DECNUM(value)->number,
                         ctxt);
            check_flags_and_throw(INTERP, ctxt);
            return dest;
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                return VTABLE_add_int(INTERP, SELF,
                                      VTABLE_get_integer(INTERP, value),
                                      dest);
                break;
            case enum_class_Float:
            default:
                return VTABLE_add_float(INTERP, SELF,
                                        VTABLE_get_number(INTERP,value),
                                        dest);
                break;
        }
    }

    VTABLE PMC *add_int(INTVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberAdd(PARROT_DECNUM(dest)->number, 
                     PARROT_DECNUM(SELF)->number, 
                     decNumberFromString(&number , cstr, ctxt),
                     ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE PMC *add_float(FLOATVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberAdd(PARROT_DECNUM(dest)->number, 
                     PARROT_DECNUM(SELF)->number, 
                     decNumberFromString(&number , cstr, ctxt),
                     ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE void i_add(PMC *value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberAdd(PARROT_DECNUM(SELF)->number,
                         PARROT_DECNUM(SELF)->number,
                         PARROT_DECNUM(value)->number,
                         ctxt);
            check_flags_and_throw(INTERP, ctxt);
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                VTABLE_i_add_int(INTERP, SELF,
                                 VTABLE_get_integer(INTERP, value));
                break;
            case enum_class_Float:
            default:
                VTABLE_i_add_float(INTERP, SELF,
                                   VTABLE_get_number(INTERP, value));
                break;
        }
    }

    VTABLE void i_add_int(INTVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberAdd(PARROT_DECNUM(SELF)->number, 
                     PARROT_DECNUM(SELF)->number, 
                     decNumberFromString(&number , cstr, ctxt),
                     ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE void i_add_float(FLOATVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberAdd(PARROT_DECNUM(SELF)->number, 
                     PARROT_DECNUM(SELF)->number, 
                     decNumberFromString(&number , cstr, ctxt),
                     ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE PMC *subtract(PMC *value, PMC* dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberSubtract(PARROT_DECNUM(dest)->number,
                              PARROT_DECNUM(SELF)->number,
                              PARROT_DECNUM(value)->number,
                              ctxt);
            check_flags_and_throw(INTERP, ctxt);
            return dest;
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                return VTABLE_subtract_int(INTERP, SELF,
                                           VTABLE_get_integer(INTERP,
                                                              value),
                                           dest);
                break;
            case enum_class_Float:
            default:
                return VTABLE_subtract_float(INTERP, SELF,
                                             VTABLE_get_number(INTERP,
                                                               value),
                                             dest);
                break;
        }

    }

    VTABLE PMC *subtract_int(INTVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberSubtract(PARROT_DECNUM(dest)->number, 
                          PARROT_DECNUM(SELF)->number, 
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE PMC *subtract_float(FLOATVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberSubtract(PARROT_DECNUM(dest)->number, 
                          PARROT_DECNUM(SELF)->number, 
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE void i_subtract(PMC *value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberSubtract(PARROT_DECNUM(SELF)->number,
                              PARROT_DECNUM(SELF)->number,
                              PARROT_DECNUM(value)->number,
                              ctxt);
            check_flags_and_throw(INTERP, ctxt);
        }
        switch (value->vtable->base_type) {
            case enum_class_Integer:
                VTABLE_i_subtract_int(INTERP, SELF,
                                      VTABLE_get_integer(INTERP,value));
                break;
            case enum_class_Float:
            default:
                VTABLE_i_subtract_float(INTERP, SELF,
                                       VTABLE_get_number(INTERP,value));
                break;
        }
    }

    VTABLE void i_subtract_int(INTVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberSubtract(PARROT_DECNUM(SELF)->number, 
                          PARROT_DECNUM(SELF)->number, 
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE void i_subtract_float(FLOATVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberSubtract(PARROT_DECNUM(SELF)->number, 
                          PARROT_DECNUM(SELF)->number, 
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE PMC *multiply(PMC *value, PMC* dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberMultiply(PARROT_DECNUM(dest)->number,
                              PARROT_DECNUM(SELF)->number,
                              PARROT_DECNUM(value)->number,
                              ctxt);
            check_flags_and_throw(INTERP, ctxt);
            return dest;
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                return VTABLE_multiply_int(INTERP, SELF,
                                           VTABLE_get_integer(INTERP,
                                                              value),
                                           dest);
                break;
            case enum_class_Float:
            default:
                return VTABLE_multiply_float(INTERP, SELF,
                                             VTABLE_get_number(INTERP,
                                                               value),
                                             dest);
                break;
        }
    }

    VTABLE PMC *multiply_int(INTVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberMultiply(PARROT_DECNUM(dest)->number, 
                          PARROT_DECNUM(SELF)->number, 
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE PMC *multiply_float(FLOATVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberMultiply(PARROT_DECNUM(dest)->number,
                          PARROT_DECNUM(SELF)->number,
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE void i_multiply(PMC *value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberMultiply(PARROT_DECNUM(SELF)->number, 
                              PARROT_DECNUM(SELF)->number,
                              PARROT_DECNUM(value)->number, 
                              ctxt);
            check_flags_and_throw(INTERP, ctxt);
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                VTABLE_i_multiply_int(INTERP, SELF,
                                      VTABLE_get_integer(INTERP,value));
                break;
            case enum_class_Float:
            default:
                VTABLE_i_multiply_float(INTERP, SELF,
                                       VTABLE_get_number(INTERP,value));
                break;
        }
    }

    VTABLE void i_multiply_int(INTVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberMultiply(PARROT_DECNUM(SELF)->number, 
                          PARROT_DECNUM(SELF)->number, 
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE void i_multiply_float(FLOATVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberMultiply(PARROT_DECNUM(SELF)->number, 
                          PARROT_DECNUM(SELF)->number, 
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE PMC *divide(PMC *value, PMC* dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        dest = pmc_new(INTERP, SELF->vtable->base_type);

        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberDivide(PARROT_DECNUM(dest)->number,
                            PARROT_DECNUM(SELF)->number,
                            PARROT_DECNUM(value)->number,
                            ctxt);
            check_flags_and_throw(INTERP, ctxt);
            return dest;
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                return VTABLE_divide_int(INTERP, SELF,
                                         VTABLE_get_integer(INTERP,
                                                            value),
                                         dest);
                break;
            case enum_class_Float:
            default:
                return VTABLE_divide_float(INTERP, SELF,
                                           VTABLE_get_number(INTERP,
                                                             value),
                                           dest);
                break;
        }
    }

    VTABLE PMC *divide_int(INTVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberDivide(PARROT_DECNUM(dest)->number,
                          PARROT_DECNUM(SELF)->number,
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE PMC *divide_float(FLOATVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberDivide(PARROT_DECNUM(dest)->number, 
                          PARROT_DECNUM(SELF)->number, 
                          decNumberFromString(&number , cstr, ctxt),
                          ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE void i_divide(PMC* value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberDivide(PARROT_DECNUM(SELF)->number, 
                            PARROT_DECNUM(SELF)->number,
                            PARROT_DECNUM(value)->number, 
                            ctxt);
            check_flags_and_throw(INTERP, ctxt);
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                VTABLE_i_divide_int(INTERP, SELF,
                                    VTABLE_get_integer(INTERP, value));
                break;
            case enum_class_Float:
            default:
                VTABLE_i_divide_float(INTERP, SELF,
                                      VTABLE_get_number(INTERP, value));
                break;
        }

    }

    VTABLE void i_divide_int(INTVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberDivide(PARROT_DECNUM(SELF)->number, 
                        PARROT_DECNUM(SELF)->number, 
                        decNumberFromString(&number , cstr, ctxt),
                        ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE void i_divide_float(FLOATVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberDivide(PARROT_DECNUM(SELF)->number, 
                        PARROT_DECNUM(SELF)->number, 
                        decNumberFromString(&number , cstr, ctxt),
                        ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE PMC *floor_divide(PMC *value, PMC* dest) {
        decContext *ctxt = get_context(PARROT_DECNUM(SELF)->context);
        dest = pmc_new(INTERP, SELF->vtable->base_type);

        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberDivideInteger(PARROT_DECNUM(dest)->number,
                                   PARROT_DECNUM(SELF)->number,
                                   PARROT_DECNUM(value)->number,
                                   ctxt);
            check_flags_and_throw(INTERP, ctxt);
            return dest;
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                return VTABLE_floor_divide_int(INTERP, SELF,
                                              VTABLE_get_integer(INTERP,
                                                                 value),
                                         dest);
                break;
            case enum_class_Float:
            default:
                return VTABLE_floor_divide_float(INTERP, SELF,
                                               VTABLE_get_number(INTERP,
                                                                 value),
                                           dest);
                break;
        }
    }

    VTABLE PMC *floor_divide_int(INTVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberDivideInteger(PARROT_DECNUM(dest)->number,
                               PARROT_DECNUM(SELF)->number,
                               decNumberFromString(&number , cstr,
                                                   ctxt),
                               ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE PMC *floor_divide_float(FLOATVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberDivideInteger(PARROT_DECNUM(dest)->number, 
                               PARROT_DECNUM(SELF)->number, 
                               decNumberFromString(&number , cstr,
                                                   ctxt),
                               ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE void i_floor_divide(PMC* value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberDivideInteger(PARROT_DECNUM(SELF)->number,
                                   PARROT_DECNUM(SELF)->number,
                                   PARROT_DECNUM(value)->number,
                                   ctxt);
            check_flags_and_throw(INTERP, ctxt);
            return;
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                VTABLE_i_floor_divide_int(INTERP, SELF,
                                     VTABLE_get_integer(INTERP, value));
                break;
            case enum_class_Float:
            default:
                VTABLE_i_floor_divide_float(INTERP, SELF,
                                      VTABLE_get_number(INTERP, value));
                break;
        }

    }

    VTABLE void i_floor_divide_int(INTVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberDivideInteger(PARROT_DECNUM(SELF)->number, 
                               PARROT_DECNUM(SELF)->number, 
                               decNumberFromString(&number , cstr, 
                                                   ctxt),
                               ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE void i_floor_divide_float(FLOATVAL value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        decNumberDivideInteger(PARROT_DECNUM(SELF)->number, 
                               PARROT_DECNUM(SELF)->number, 
                               decNumberFromString(&number , cstr, 
                                                   ctxt),
                               ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);
    }

    VTABLE PMC *pow(PMC *value, PMC* dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        if ( value->vtable->base_type ==  SELF->vtable->base_type){
            decNumberPower(PARROT_DECNUM(dest)->number,
                           PARROT_DECNUM(SELF)->number,
                           PARROT_DECNUM(value)->number,
                           ctxt);
            check_flags_and_throw(INTERP, ctxt);
            return dest;
        }

        switch (value->vtable->base_type) {
            case enum_class_Integer:
                return VTABLE_pow_int(INTERP, SELF,
                                      VTABLE_get_integer(INTERP, value),
                                      dest);
                break;
            case enum_class_Float:
            default:
                return VTABLE_pow_float(INTERP, SELF,
                                        VTABLE_get_number(INTERP,
                                                          value),
                                        dest);
                break;
        }
    }

    VTABLE PMC *pow_int(INTVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_int(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberPower(PARROT_DECNUM(dest)->number,
                       PARROT_DECNUM(SELF)->number,
                       decNumberFromString(&number , cstr, ctxt),
                       ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE PMC *pow_float(FLOATVAL value, PMC *dest) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        STRING     *pstr = Parrot_str_from_num(INTERP, value);
        char       *cstr = Parrot_str_to_cstring(INTERP, pstr);
        decNumber   number;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberPower(PARROT_DECNUM(dest)->number,
                       PARROT_DECNUM(SELF)->number,
                       decNumberFromString(&number , cstr, ctxt),
                       ctxt);
        Parrot_str_free_cstring(cstr);
        check_flags_and_throw(INTERP, ctxt);

        return dest;
    }

    VTABLE INTVAL cmp(PMC *value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        decNumber   temp;
        char       *cstr;

        if (value->vtable->base_type == SELF->vtable->base_type) {
            decNumberCopy(&temp, PARROT_DECNUM(value)->number);
        } else {
            switch (value->vtable->base_type) {
                case enum_class_Integer:
                    cstr = Parrot_str_to_cstring(INTERP, 
                               Parrot_str_from_int(INTERP,
                                   VTABLE_get_integer(INTERP, value)));
                    break;
                case enum_class_Float:
                default:
                    cstr = Parrot_str_to_cstring(INTERP,
                               Parrot_str_from_num(INTERP,
                                   VTABLE_get_number(INTERP, value)));
                    break;
            }

            decNumberFromString(&temp, cstr, ctxt);
            Parrot_str_free_cstring(cstr);
            check_flags_and_throw(INTERP, ctxt);
        }

        decNumberCompare(&temp, PARROT_DECNUM(SELF)->number, &temp, 
                         ctxt);

        if (decNumberIsNaN(&temp))
            Parrot_ex_throw_from_c_args(interp, NULL, 
                                        EXCEPTION_INVALID_OPERATION,
                                        "Tried to compare a NaN.");

        return decNumberToInt32(&temp, ctxt);
    }

    METHOD ieee754_cmp(PMC *value) {
        decContext *ctxt = get_context( PARROT_DECNUM(SELF)->context );
        decNumber   temp;
        INTVAL      result;
        
        if (value->vtable->base_type != SELF->vtable->base_type)
            Parrot_ex_throw_from_c_args(interp, NULL, 
                                        EXCEPTION_INVALID_OPERATION,
                                        "Argument is not a DecNum.");

        decNumberCompareTotal(&temp, PARROT_DECNUM(SELF)->number,
                              PARROT_DECNUM(value)->number, ctxt);
        result = decNumberToInt32(&temp, ctxt);
        RETURN(INTVAL result);

    }

    VTABLE INTVAL is_equal(PMC *value) {
        return !VTABLE_cmp(INTERP, SELF, value);
    }

    VTABLE PMC *absolute(PMC *dest) {
        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberCopyAbs(PARROT_DECNUM(dest)->number,
                         PARROT_DECNUM(SELF)->number);

        return dest;
    }

    VTABLE void i_absolute() {
        decNumberCopyAbs(PARROT_DECNUM(SELF)->number,
                         PARROT_DECNUM(SELF)->number);
    }

    VTABLE PMC *neg(PMC *dest) {
        dest = pmc_new(INTERP, SELF->vtable->base_type);
        decNumberCopyNegate(PARROT_DECNUM(dest)->number,
                            PARROT_DECNUM(SELF)->number);

        return dest;
    }


    VTABLE void i_neg() {
        decNumberCopyNegate(PARROT_DECNUM(SELF)->number,
                            PARROT_DECNUM(SELF)->number);
    }

}

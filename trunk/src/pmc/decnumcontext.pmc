#include <string.h>
#include "parrot/parrot.h"
#include "../decNumber/decNumber.h"
#include "definitions.h"

#define MAX_DIGITS DECNUMDIGITS
#define MIN_DIGITS 1

#define MIN_EMIN -999999999 
#define MAX_EMIN 0 
    
#define MIN_EMAX 0 
#define MAX_EMAX 999999999

static STRING *
rounding_mode_to_str(PARROT_INTERP, struct decContext *ctx) {
    STRING *rounding_str;

    switch (decContextGetRounding(ctx)) {
        case DEC_ROUND_CEILING:
            rounding_str = Parrot_str_new(interp,
                                          "DEC_ROUND_CEILING", 0);
            break;
        case DEC_ROUND_UP:
            rounding_str = Parrot_str_new(interp,
                                          "DEC_ROUND_UP", 0);
            break;
        case DEC_ROUND_HALF_UP:
            rounding_str = Parrot_str_new(interp,
                                          "DEC_ROUND_HALF_UP", 0);
            break;
        case DEC_ROUND_HALF_EVEN:
            rounding_str = Parrot_str_new(interp,
                                          "DEC_ROUND_HALF_EVEN", 0);
            break;
        case DEC_ROUND_HALF_DOWN:
            rounding_str = Parrot_str_new(interp,
                                          "DEC_ROUND_HALF_DOWN", 0);
            break;
        case DEC_ROUND_DOWN:
            rounding_str = Parrot_str_new(interp,
                                          "DEC_ROUND_DOWN", 0);
            break;
        case DEC_ROUND_FLOOR:
            rounding_str = Parrot_str_new(interp,
                                          "DEC_ROUND_FLOOR", 0);
            break;
        case DEC_ROUND_05UP:
            rounding_str = Parrot_str_new(interp,
                                          "DEC_ROUND_05UP", 0);
            break;
        default: /* Sould never happen*/
            Parrot_ex_throw_from_c_args(interp, NULL,
                                        EXCEPTION_INVALID_OPERATION,
            "Invalid rounding mode found on the decContext structure!");
    }
    return rounding_str;
}

static enum rounding
str_to_rounding_mode(PARROT_INTERP, STRING *round) {
        char *rounding_str = Parrot_str_to_cstring(interp, round);
        enum rounding rounding_enum;

        if (!strcmp(rounding_str, "DEC_ROUND_CEILING")) {
            /* Round towards +Infinity. */
            rounding_enum = DEC_ROUND_CEILING;
        } else if (!strcmp(rounding_str, "DEC_ROUND_DOWN")) {
            /* Round towards 0 (truncation). */
            rounding_enum = DEC_ROUND_DOWN;
        } else if (!strcmp(rounding_str, "DEC_ROUND_FLOOR")) {
            /* Round towards -Infinity. */
            rounding_enum = DEC_ROUND_FLOOR;
        } else if (!strcmp(rounding_str, "DEC_ROUND_HALF_DOWN")) {
            /* Round to nearest; if equidistant, round down. */
            rounding_enum = DEC_ROUND_HALF_DOWN;
        } else if (!strcmp(rounding_str, "DEC_ROUND_HALF_EVEN")) {
            /* Round to nearest; if equidistant, round so that the final
               digit is even. */
            rounding_enum = DEC_ROUND_HALF_EVEN;
        } else if (!strcmp(rounding_str, "DEC_ROUND_HALF_UP")) {
            /* Round to nearest; if equidistant, round up. */
            rounding_enum = DEC_ROUND_HALF_UP;
        } else if (!strcmp(rounding_str, "DEC_ROUND_UP")) {
            /* Round away from 0. */
            rounding_enum = DEC_ROUND_UP;
        } else if (!strcmp(rounding_str, "DEC_ROUND_05UP")) {
            /* The same as DEC_ROUND_UP, except that rounding up only 
               occurs if the digit to be rounded up is 0 or 5 and after
               Overflow the result is the same as for DEC_ROUND_DOWN. */
            rounding_enum = DEC_ROUND_05UP;
        } else {
            Parrot_str_free_cstring(rounding_str);
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,  
            "Invalid rounding mode provided!");
        }

        Parrot_str_free_cstring(rounding_str);

        return rounding_enum;
}

static void
set_context_defaults(decContext *ctx) {
    ctx->emin  = -999999;
    ctx->emax  = 999999;
    decContextDefault(ctx, DEC_INIT_BASE);
    decContextZeroStatus(ctx);
    ctx->traps = 0;

}

static PMC *DecNumContext_PMC = NULL;

pmclass DecNumContext 
    singleton dynpmc 
    group decnumber 
    extends DecBase {

    VTABLE PMC *instantiate(PMC *sig) {
        UNUSED(sig)
        return PMCNULL;
    }

    VTABLE void *get_pointer() {
        return DecNumContext_PMC;
    }

    VTABLE void set_pointer(void *ptr) {
        DecNumContext_PMC = (PMC *) ptr;
    }

    VTABLE void init() {
        Parrot_DecNumContext_attributes *attr = NULL;

        if (decContextTestEndian(1)) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, 
            EXCEPTION_INVALID_OPERATION,  
            "This dynpmc has been compiled with the wrong endianness.");
        }

        if ( PMC_data(SELF) == NULL ) {
            attr = mem_allocate_zeroed_typed(Parrot_DecNumContext_attributes);
            PMC_data(SELF) = attr;

            PObj_get_FLAGS(SELF) &= ~IEEE754_CMP_FLAG;
            attr->exceptions = DEC_Errors;
            attr->ctx = mem_allocate_typed(decContext);
            set_context_defaults(attr->ctx);

            PObj_active_destroy_SET(SELF);
        }
    }

    VTABLE void destroy() {
        mem_sys_free(PARROT_DECNUMCONTEXT(SELF)->ctx);
        mem_sys_free(PMC_data(SELF));
    }

    VTABLE void freeze(visit_info *info) {
        decContext *ctx = PARROT_DECNUMCONTEXT(SELF)->ctx;
        STRING     *str = rounding_mode_to_str(INTERP, ctx);

        SUPER(info);

        VTABLE_push_integer(INTERP, info->image_io, ctx->digits);
        VTABLE_push_integer(INTERP, info->image_io, ctx->emax);
        VTABLE_push_integer(INTERP, info->image_io, ctx->emin);
        VTABLE_push_integer(INTERP, info->image_io, ctx->clamp);
        VTABLE_push_string(INTERP, info->image_io, str);

    }

    VTABLE void thaw(visit_info *info) {
        INTVAL      context_type;
        STRING     *str;
        decContext *ctx;

        context_type = pmc_type(interp, CONST_STRING(interp, "DecNumContext"));
        ctx = PARROT_DECNUMCONTEXT(pmc_new(interp, context_type))->ctx;

        SUPER(info);

        ctx->digits = VTABLE_shift_integer(INTERP, info->image_io);
        ctx->emax = VTABLE_shift_integer(INTERP, info->image_io);
        ctx->emin = VTABLE_shift_integer(INTERP, info->image_io);
        ctx->clamp = VTABLE_shift_integer(INTERP, info->image_io);
        str = VTABLE_shift_string(INTERP, info->image_io);
        ctx->round = str_to_rounding_mode(INTERP, str);

    }

    METHOD restore_defaults() {
        set_context_defaults(PARROT_DECNUMCONTEXT(SELF)->ctx);
    }

    METHOD clear_status() {
        decContextZeroStatus(PARROT_DECNUMCONTEXT(SELF)->ctx);
    }

    METHOD set_digits(INTVAL digits) {
        if ( digits > MAX_DIGITS || digits < MIN_DIGITS) { 
            Parrot_ex_throw_from_c_args(INTERP, NULL, 
                                        EXCEPTION_INVALID_OPERATION,
                                  "Invalid number of digits provided!");
        } else {
            PARROT_DECNUMCONTEXT(SELF)->ctx->digits = digits;
        }
    }

    METHOD get_digits() {
        INTVAL  digits;

        digits = PARROT_DECNUMCONTEXT(SELF)->ctx->digits;

        RETURN(INTVAL digits);
    }

    METHOD set_emin(INTVAL emin) {
        if ( emin > MAX_EMIN || emin < MIN_EMIN) {
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                                        EXCEPTION_INVALID_OPERATION,
                                  "Invalid minimum exponent provided!");
        } else {
            PARROT_DECNUMCONTEXT(SELF)->ctx->emin = emin;
        }
    }

    METHOD get_emin() {
        INTVAL  emin;

        emin = PARROT_DECNUMCONTEXT(SELF)->ctx->emin;

        RETURN(INTVAL emin);

    }

    METHOD set_clamp(INTVAL clamp) {
        if ( clamp != 0 ){
            PARROT_DECNUMCONTEXT(SELF)->ctx->clamp = 1;
        } else {
            PARROT_DECNUMCONTEXT(SELF)->ctx->clamp = 0;
        }
    }

    METHOD get_clamp() {
        INTVAL clamp;

        clamp = PARROT_DECNUMCONTEXT(SELF)->ctx->clamp;

        RETURN(INTVAL *clamp);
    }

    METHOD set_ieee754_cmp(INTVAL ieee754_cmp) {
        if ( ieee754_cmp != 0 ){
            PObj_get_FLAGS(SELF) |= IEEE754_CMP_FLAG;
        } else {
            PObj_get_FLAGS(SELF) &= ~IEEE754_CMP_FLAG;
        }
    }

    METHOD get_ieee754_cmp() {
        INTVAL ieee754_cmp = 0;

        if (PObj_get_FLAGS(SELF) & IEEE754_CMP_FLAG) 
            ieee754_cmp = 1;

        RETURN(INTVAL *ieee754_cmp);
    }

    METHOD set_exceptions(INTVAL exceptions) {
        PARROT_DECNUMCONTEXT(SELF)->exceptions = exceptions;
    }

    METHOD get_exceptions() {
        INTVAL exceptions;

        exceptions = PARROT_DECNUMCONTEXT(SELF)->exceptions;

        RETURN(INTVAL *exceptions);
    }

    METHOD set_emax(INTVAL emax) {
        if ( emax > MAX_EMAX || emax < MIN_EMAX) {
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                                        EXCEPTION_INVALID_OPERATION,
                                  "Invalid maximum exponent provided!");
        } else {
            PARROT_DECNUMCONTEXT(SELF)->ctx->emax = emax;
        }
    }

    METHOD get_emax() {
        INTVAL emax;

        emax = PARROT_DECNUMCONTEXT(SELF)->ctx->emax;

        RETURN(INTVAL emax);
    }

    METHOD get_rounding_mode() {
        STRING *s;
        s = rounding_mode_to_str(INTERP,
                                 PARROT_DECNUMCONTEXT(SELF)->ctx);

        RETURN(STRING *s);
    }

    METHOD set_rounding_mode(STRING *rounding) {

        decContextSetRounding(PARROT_DECNUMCONTEXT(SELF)->ctx, 
                              str_to_rounding_mode(INTERP, rounding));

    }

}
